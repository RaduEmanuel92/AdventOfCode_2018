#!/usr/bin/ruby
def check_collision(rectgl_1 , rectgl_2)
	# determine if rectangles  'collide'
	# rectangles are defined by 4 (x,y) points
  # 0  1  2  3  4  5  6  7  8 
  #r1 xA yA xB yB xC yC xD yD
  #r2 xE yE xF yF xG yG xH yH
  #	
	len_y = 0
	len_x = 0
	if rectgl_1[4] > rectgl_2[2]
		len_y = ([rectgl_2[4], rectgl_1[4]].min - [rectgl_2[2], rectgl_1[2]].max).abs
		len_x = ([rectgl_2[7], rectgl_1[7]].min - [rectgl_2[1], rectgl_1[1]].max).abs		 
	end
		
	overlap = len_x * len_y
end

def sort_afer_y_origin(claim_list)
	# sorts list of arrays after a y coordinate
	# element looks like:
	#	[id, start_x, start_y,]
	
	claim_list.sort{|x,y| x[2]<=>y[2]}
end

def arr_to_claim arr
    ret = []
    (arr[1]...(arr[1]+arr[3])).each do |x|
        (arr[2]...(arr[2]+arr[4])).each do |y|
            ret.push [[x, y], [1, [arr[0]]]]
        end
    end
    return ret.to_h
end

$overlaps = {}
DATA = File.read('input_3.dat')
    .scan(/\#(\d+) \@ (\d+),(\d+): (\d+)x(\d+)/)
    .map{ |n| n.map(&:to_i) }
    .reduce({}) do |t, e|
        if not $overlaps.include? e[0]
            $overlaps[e[0]] = false
        end
        t.merge(arr_to_claim e) do |k, o, n|
            r = [o.first + n.first, o.last + n.last]
            r.last.each{ |x| $overlaps[x] = r.last.size > 1 }
            r
        end
    end

PART1 = DATA.select{|k, v| v.first > 1 }.count
PART2 = $overlaps.select{|k, v| v == false }.map{ |k, v| k }.join(", ")

puts 'Part 1: %s' % PART1
puts 'Part 2: %s' % PART2
